<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        // 9 super 关键字
        // 我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。
        // demo1
        const proto = {
            foo: 'hello',
            bar: function() {
                console.log('bar')
                return 'bar return'
            }
        }
        const obj = {
            find() {
               return super.bar;
            },
            bar: function() {

            }
        }
        Object.setPrototypeOf(obj, proto);
        console.log(obj)

        // 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。

        // 报错 (super用在属性里面)
        // const obj = {
        //     foo: super.foo // 'super' keyword unexpected here
        // }
        // 报错 (super用在一个函数里面)
        // const obj = {
        //     foo: () => super.foo // 'super' keyword unexpected here
        // }
        // 报错 (super用在一个函数里面)
        // const obj2 = {
        //     foo: function () {
        //         return super.foo; // 'super' keyword unexpected here
        //     }
        // }    


        // 只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。
        const proto2 = {
            x: '2proto2',
            foo() {
                return this.x;
            }
        }
        const obj2 = {
            x: 'obj2',
            foo() {
                return super.foo()
            }
        }
        Object.setPrototypeOf(obj2, proto2)
        console.log(obj2.foo()) // obj2
        // 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。
        
    </script>
</head>
<body>
    
</body>
</html>