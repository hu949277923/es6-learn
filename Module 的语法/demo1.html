<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script>
        // Module 的语法
        
        // CommonJS模块
        let { stat, exists, readFile } = require('fs');

        // 等同于
        let _fs = require('fs');
        let stat = _fs.stat;
        let exists = _fs.exists;
        let readfile = _fs.readfile;
        // 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。

        // // ES6模块
        import { stat, exists, readFile } from 'fs';
        // 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。


        // 总结
        // 1、ES6 模块的设计思想：尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量
        // 2、在ES6之前，社区制定了一些模块加载方案，最主要有commonjs与AMD两种。前者用于服务器后者用于浏览器。es6之后，实现了模块功能，完全可以取代commonjs和AMD规范，成为浏览器和服务器的通用的模块解决方案
        // 3、es6使得编译时就可以确定依赖关系以及输入和输出的变量。commonjs和AMD模块，只能在运行时确定
        // 4、ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。
        // 5、由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。
        // 除了静态加载带来的各种好处，ES6 模块还有以下好处
        // - 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
        // - 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
        // - 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
    </script>
</head>
<body>
    
</body>
</html>